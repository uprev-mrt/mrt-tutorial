/**
  * @file hts221.c
  * @author generated by mrt-device utility 
  * @link [https://github.com/uprev-mrt/mrtutils/wiki/mrt-device]
  * @brief Device driver for HTS221 device
  *
  */

#include "hts221.h"



/**
 * @brief initializes device
 * @param dev ptr to HTS221 device
 * @return status 
 */
static mrt_status_t hts_init(hts221_t* dev)
{   
    /* Initialize Register Descriptors */
    REG_INIT( dev->mWhoAmI , HTS_REG_WHO_AM_I_ADDR , uint8_t, REG_PERM_R , 0xBC  );
    REG_INIT( dev->mAvConf , HTS_REG_AV_CONF_ADDR , uint8_t, REG_PERM_RW , 0x1B  );
    REG_INIT( dev->mCtrl1 , HTS_REG_CTRL1_ADDR , uint8_t, REG_PERM_RW , 0x00  );
    REG_INIT( dev->mCtrl2 , HTS_REG_CTRL2_ADDR , uint8_t, REG_PERM_RW , 0x00  );
    REG_INIT( dev->mCtrl3 , HTS_REG_CTRL3_ADDR , uint8_t, REG_PERM_RW , 0x00  );
    REG_INIT( dev->mStatus , HTS_REG_STATUS_ADDR , uint8_t, REG_PERM_R , 0x00  );
    REG_INIT( dev->mHumidityOut , HTS_REG_HUMIDITY_OUT_ADDR , int16_t, REG_PERM_R , 0x0000  );
    REG_INIT( dev->mTempOut , HTS_REG_TEMP_OUT_ADDR , int16_t, REG_PERM_R , 0x0000  );
    REG_INIT( dev->mH0RhX2 , HTS_REG_H0_RH_X2_ADDR , uint8_t, REG_PERM_R , 0x00  );
    REG_INIT( dev->mH1RhX2 , HTS_REG_H1_RH_X2_ADDR , uint8_t, REG_PERM_R , 0x00  );
    REG_INIT( dev->mT0DegcX8 , HTS_REG_T0_DEGC_X8_ADDR , uint8_t, REG_PERM_R , 0x00  );
    REG_INIT( dev->mT1DegcX8 , HTS_REG_T1_DEGC_X8_ADDR , uint8_t, REG_PERM_R , 0x00  );
    REG_INIT( dev->mT1t0Msb , HTS_REG_T1T0_MSB_ADDR , uint8_t, REG_PERM_R , 0x00  );
    REG_INIT( dev->mH0T0Out , HTS_REG_H0_T0_OUT_ADDR , int16_t, REG_PERM_R , 0x0000  );
    REG_INIT( dev->mH1T0Out , HTS_REG_H1_T0_OUT_ADDR , int16_t, REG_PERM_R , 0x0000  );
    REG_INIT( dev->mT0Out , HTS_REG_T0_OUT_ADDR , int16_t, REG_PERM_R , 0x0000  );
    REG_INIT( dev->mT1Out , HTS_REG_T1_OUT_ADDR , int16_t, REG_PERM_R , 0x0000  );


    /*user-block-init-start*/

     dev->mPrevHum =0;
    dev->mPrevTemp =0;

    /* device requires a bit ORd with register address to auto increment reg addr */
    dev->mRegDev.mAutoIncrement = true;
    dev->mRegDev.mAiMask = 0x80;

    /* Load calibration data */
     uint8_t H0_rh_x2, H1_rh_x2, T0_degC_x8, T1_degC_x8, T1T0_msb;

    /* These registers can be read directly into the cal values */
    dev->mCalData.H0_T0_OUT = hts_read_reg(dev, &dev->mH0T0Out);
    dev->mCalData.H1_T0_OUT = hts_read_reg(dev, &dev->mH1T0Out);
    dev->mCalData.T0_out = hts_read_reg(dev, &dev->mT0Out);
    dev->mCalData.T1_out = hts_read_reg(dev, &dev->mT1Out);

    /* These registers need to be processed to get the values we need */
    H0_rh_x2 = hts_read_reg(dev, &dev->mH0RhX2);
    H1_rh_x2 = hts_read_reg(dev, &dev->mH1RhX2);
    T0_degC_x8 = hts_read_reg(dev, &dev->mT0DegcX8);
    T1_degC_x8 = hts_read_reg(dev, &dev->mT1DegcX8);
    T1T0_msb = hts_read_reg(dev, &dev->mT1t0Msb);

    /* These values just need to be divided down (for some reason they are stored with a multiplier of 2..) */
    dev->mCalData.H0_rH = H0_rh_x2 >> 1;
    dev->mCalData.H1_rH = H1_rh_x2 >> 1;

    /* T0 and T1 are 10 bits, the MSBs are stored together in the T1T0_MSB Register. They have to be put together, and then divided by 8.. (see link to application note) */
    dev->mCalData.T0_degC = ((uint16_t) T0_degC_x8 | (((uint16_t)(T1T0_msb & 0x03)) << 8)) >> 3;
    dev->mCalData.T1_degC = ((uint16_t) T1_degC_x8 | (((uint16_t)(T1T0_msb & 0x0C)) << 6)) >> 3;

    /*user-block-init-end*/

    return MRT_STATUS_OK;
}


mrt_status_t hts_init_i2c(hts221_t* dev, mrt_i2c_handle_t i2c)
{
    mrt_status_t status;

    status = init_i2c_register_device(&dev->mRegDev, i2c, HTS221_I2C_ADDRESS, HTS221_REG_ADDR_SIZE );

    hts_init(dev);


    /*user-block-init-i2c-start*/
    /*user-block-init-i2c-end*/
    
    return MRT_STATUS_OK;
}

mrt_status_t hts_test(hts221_t* dev)
{
    /*user-block-test-start*/

    if( hts_read_reg(dev, &dev->mWhoAmI) == HTS_WHO_AM_I_DEFAULT)
    {
        return MRT_STATUS_OK;
    }

    /*user-block-test-end*/
    return MRT_STATUS_ERROR;
}


/*user-block-bottom-start*/

int hts_read_humidity(hts221_t* dev)
{
    int16_t raw_adc;
    float tmp_f;

    //check to make sure data is ready, if not just use previous value
    if(! hts_check_flag(dev,&dev->mStatus, HTS_STATUS_HUM_READY))
    {
        return dev->mPrevHum;
    }

    //get raw adc value
    raw_adc = hts_read_reg(dev, &dev->mHumidityOut);

    //Use calibration coefs to interpolate data to RH%
    tmp_f = ((float)(raw_adc - dev->mCalData.H0_T0_OUT) * (float)(dev->mCalData.H1_rH - dev->mCalData.H0_rH) / (float)(dev->mCalData.H1_T0_OUT - dev->mCalData.H0_T0_OUT))  +  dev->mCalData.H0_rH;

    dev->mPrevHum = tmp_f * 100;
    return dev->mPrevHum;
}

int hts_read_temp(hts221_t* dev)
{   
    int16_t raw_adc;
    float tmp_f;

    //check to make sure data is ready, if not just use previous value
    if(! hts_check_flag(dev,&dev->mStatus, HTS_STATUS_TEMP_READY))
    {
        return dev->mPrevTemp;
    }
    

    //get raw adc value
    raw_adc = hts_read_reg(dev, &dev->mTempOut);

    //Use calibration coefs to interpolate data to deg C
    tmp_f = ((float)(raw_adc - dev->mCalData.T0_out) * (float)(dev->mCalData.T1_degC - dev->mCalData.T0_degC) / (float)(dev->mCalData.T1_out - dev->mCalData.T0_out))  +  dev->mCalData.T0_degC;
    
    
    dev->mPrevTemp = tmp_f * 100;
    return dev->mPrevTemp;
}
/*user-block-bottom-end*/
